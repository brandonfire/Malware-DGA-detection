package Maldetect;
import java.io.*;
import java.net.InetAddress;
//import java.awt.*;
import java.security.*;
//import java.util.Arrays;
//import java.util.Dictionary;
//import java.util.Set;
//import java.io.*;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
//import javax.swing.*;
import weka.core.*;
import weka.core.Instances;
import java.io.BufferedReader;
import java.io.FileReader;
//import weka.classifiers.*;
//import weka.classifiers.trees.j48.;
import weka.classifiers.trees.J48;
import weka.classifiers.functions.MultilayerPerceptron;
import weka.classifiers.Evaluation;
//import weka.core.Debug;
import weka.classifiers.misc.SerializedClassifier;
import weka.classifiers.evaluation.ThresholdCurve;
//import weka.classifiers.bayes.HMM;
import weka.gui.visualize.*;
import org.apache.commons.net.WhoisClient;
//import org.junit.Test;
//import static org.junit.Assert.assertEquals;
public class DictionaryValidWords {
	

	 private static final String IPADDRESS_PATTERN =
			"([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\." +
			"([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\." +
			"([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\." +
			"([01]?\\d\\d?|2[0-4]\\d|25[0-5])";
	 private static final String Email_p = "^[_A-Za-z0-9-\\+]+(\\.[_A-Za-z0-9-]+)*@[A-Za-z0-9-]+(\\.[A-Za-z0-9]+)*(\\.[A-Za-z]{2,})$;";
	 private static String Countries = "Server Name";
	 private static final Pattern pattern2 = Pattern.compile(Countries);
	 private static final Pattern pattern = Pattern.compile(IPADDRESS_PATTERN);
	 private static final Pattern pattern3 = Pattern.compile(Email_p);
	    
	    
	private static final Set<String> dictionary = new TreeSet<String>();
	private static final HashMap<String,Integer> pscore = new HashMap<String,Integer>();
    static {
    	
    	Scanner inp, ngram;
    	try 
    	{
    		inp = new Scanner(new File("wordlist.txt"));
    	} catch(Exception e)
    	{	
    		System.out.println("Error, file cannot be opened, please check the file path.");
    		inp = new Scanner(System.in);
    		e.printStackTrace();
    	}
    	try 
    	{
    		ngram = new Scanner(new FileInputStream("ngramscore2.txt"), "UTF-8");
    		
    	} catch(Exception e)
    	{	
    		System.out.println("Error, file cannot be opened, please check the file path.");
    		ngram = new Scanner(System.in);
    		e.printStackTrace();
    	}
    	int i;
    	for(i =0;i<676;i++){
    		String tem = ngram.nextLine();
    		String parts[] = tem.split(" ");
    		int count = Integer.parseInt(parts[1]);
    		pscore.put(parts[0], count);

    	}
    	
    	
    	for(i =0;i<69903;i++){
    		String tem = inp.nextLine();
    		dictionary.add(tem);
    	}

    	ngram.close();
    	inp.close();
    }
    public static void mixinput(){
    	Scanner dga, top;
    	List<String> dlist = new ArrayList<String>();
    	//List<String> tlist = new ArrayList<String>();
    	try 
    	{
    		dga = new Scanner(new File("DGA1.txt"));
    		for(int i =0;i<100;i++){
        		String tem = dga.nextLine();
        		//String parts[] = tem.split(" ");
        		//int count = Integer.parseInt(parts[1]);
        		dlist.add(tem);

        	}	
    	} catch(Exception e)
    	{	
    		System.out.println("Error, file cannot be opened, please check the file path.");
    		System.exit(1);
    		e.printStackTrace();
    	}
    	try 
    	{
    		top = new Scanner(new File("top1000website.txt"));
    		for(int i =0;i<1000;i++){
        		String tem = top.nextLine();
        		String parts[] = tem.split(",");
        		//int count = Integer.parseInt(parts[1]);
        		dlist.add(parts[1]);

        	}	
    	} catch(Exception e)
    	{	
    		System.out.println("Error, file cannot be opened, please check the file path.");
    		e.printStackTrace();
    		System.exit(1);
    	}
    	long seed = 123456789;
    	Collections.shuffle(dlist, new Random(seed));
    	try{
    		PrintWriter writer = new PrintWriter("testinput.txt", "UTF-8");
    		for(int i =0;i<dlist.size();i++){
    			writer.println(dlist.get(i));
    		}
    		writer.close();
    		
    	} catch(Exception e)
    	{	
    		System.out.println("Error, file cannot be created, please check the file path.");
    		e.printStackTrace();
    		System.exit(1);
    	}
    	
    	
    	//System.out.println(dlist);
    	
    	
    }
    
    
    public static Set<String> findValidStrings(String str) {
        if (str.length() ==  0) {
            throw new IllegalArgumentException("Strings of length 0 are illegal");
        }

        final Set<String> validWords = new HashSet<String>(); 
        for (int i = 0; i < str.length(); i++) {
            StringBuilder sb = new StringBuilder();
            for (int j = i; j < str.length(); j++) {
                sb.append(str.charAt(j)); // O(1) complexity.
                if (dictionary.contains(sb.toString())) {
                    validWords.add(sb.toString());
                }
            }
        }
        return validWords;
    }
    public static double[] meaning_word_score(String oris)
    {
    	String domain = oris;
    	try{
    	domain = oris.split("\\.")[0];///.split("\\.")[0];
    	} catch (Exception e){
    		System.out.println("Wrong split");
    		System.out.println(e);
    	}
    	//System.out.println(oris+" then "+domain);
    	Set<String> oriset = DictionaryValidWords.findValidStrings(domain);
    	int size = domain.length();
    	Set<String> Words = new HashSet<String>();
    	boolean passcheck = true;
//    	int x =oriset.size();
    	double[] score = {0,0,0};
    	int sub_length = 0;
    	
    	//This nest loop use O(n2)to get rid of all the subwords 
    	for(String sa: oriset){
    		if(sa.length()<3){
    			continue;
    			}
    		passcheck = true;
    		for(String ss: oriset){
    			if((!sa.equals(ss)) && ss.contains(sa)){
    				passcheck = false;
    				break;
    			}
    		}
    		
    		
    	if(passcheck)
    		{
    			sub_length += sa.length();// The first sub_length is sum length of all the words
    									  // We still need to consider the head-tail overlap
    			Words.add(sa);
    	    }	
    	}
    	//System.out.println(Words);
    	int indexofs;
    	//use a TreeMap to record the index and length of each word
    	Map<Integer,Integer> d = new TreeMap<Integer,Integer>();
    	for(String s: Words){
    		indexofs = oris.indexOf(s);
    		d.put(indexofs, s.length());
    	}
    	
    	
    	Iterator iterator = d.entrySet().iterator();
    	int k = 0,v =0;
    	int maxlength = 0;
    	//boolean delcheck = false;
    	while(iterator.hasNext()) {
            Map.Entry mentry = (Map.Entry)iterator.next();
            //if each word cover the next word, then only keep the longer word, substract the length of the short value from sub_length.
            //if(!delcheck){
            if((k+v)>(int) mentry.getKey()){
            	
            	if(v<=(int) mentry.getValue()){
            		sub_length = sub_length - v;
            		//System.out.print("key is: "+ k + " & Value is: ");
            		//System.out.println(v);
            	} 
            	/*else {// if we use this else statement, we will delete some words twice if it is overlapped 2 times.
            	 //so we only delete the previous value. 
            		sub_length = sub_length - (int)mentry.getValue();
            		System.out.print("key is: "+ (int) mentry.getKey() + " & Value is: ");
            		System.out.println((int) mentry.getValue());
            	}*/
             }
           // }
            k = (int) mentry.getKey();
            v = (int) mentry.getValue();
            if(maxlength<v){
            	maxlength = v;
            }
         }
    	Pattern p = Pattern.compile("[0-9]");
    	Matcher m = p.matcher(domain);
    	int nucount = 0;
    	while(m.find()){
    		nucount++;
    	}
    	//System.out.println("the maxlength");
    	//System.out.println(maxlength);
    	//System.out.println("number count:");
    	//System.out.println(nucount);
    	//Here we need to get only one word for computer the meanlingful score.
    	//System.out.println(sub_length);
    	score[0] = sub_length*1.0/size;
    	score[1] = maxlength*1.0/size;
    	score[2] = nucount*1.0/size;
    	return score;
    }
    
    public static double prouncval(String oristr){
    	double ps =0;
    	PrintWriter writer;
    	try{
    		writer = new PrintWriter("ngramscore2.txt", "UTF-8");
    		Set set = pscore.entrySet();
            Iterator iterator = set.iterator();
            while(iterator.hasNext()) {
               Map.Entry mentry = (Map.Entry)iterator.next();
               writer.println(mentry.getKey() + " "+mentry.getValue());
            }
            writer.close();
    		} catch(Exception e)
    	{	
    			e.printStackTrace();
    			System.exit(1);
    	}
    	
    	
    	int i = 0;
    	for(;i<oristr.length()-1;i++){
    		try 
        	{
    			ps += (int) pscore.get(oristr.substring(i, i+2));
        		
        	} catch(Exception e)
        	{	
        		
        	}
    	}
    	
    	return ps/(oristr.length()*10000);
    	
    }
    public static String whoisdata(String domainname){
    	//StringBuilder sb = new StringBuilder("");
    	WhoisClient wic = new WhoisClient();
    	String whoisData1;
    	try {
    		
    	    
            wic.connect(WhoisClient.DEFAULT_HOST);
            wic.setDefaultTimeout(2000);
            wic.setSoTimeout(2000);
            whoisData1 = wic.query("=" + domainname);
            //sb.append(whoisData1);
            wic.disconnect();
            if(whoisData1.contains("No match for ")){
            	return " ";
            }
            return whoisData1;
            }catch (Exception e) {
            	e.printStackTrace();
        	return " ";   
         }

    }
    public static String getHostName(final String ip)
    {
      String retVal = null;
      final String[] bytes = ip.split("\\.");
      if (bytes.length == 4)
      {
         try
         {
            final java.util.Hashtable<String, String> env = new java.util.Hashtable<String, String>();
            env.put("java.naming.factory.initial", "com.sun.jndi.dns.DnsContextFactory");
            final javax.naming.directory.DirContext ctx = new javax.naming.directory.InitialDirContext(env);
            final String reverseDnsDomain = bytes[3] + "." + bytes[2] + "." + bytes[1] + "." + bytes[0] + ".in-addr.arpa";
            final javax.naming.directory.Attributes attrs = ctx.getAttributes(reverseDnsDomain, new String[]
            {
               "PTR",
            });
            for (final javax.naming.NamingEnumeration<? extends javax.naming.directory.Attribute> ae = attrs.getAll(); ae.hasMoreElements();)
            {
               final javax.naming.directory.Attribute attr = ae.next();
               final String attrId = attr.getID();
               for (final java.util.Enumeration<?> vals = attr.getAll(); vals.hasMoreElements();)
               {
                  String value = vals.nextElement().toString();
                  // System.out.println(attrId + ": " + value);

                  if ("PTR".equals(attrId))
                  {
                     final int len = value.length();
                     if (value.charAt(len - 1) == '.')
                     {
                        // Strip out trailing period
                        value = value.substring(0, len - 1);
                     }
                     retVal = value;
                  }
               }
            }
            ctx.close();
         }
         catch (final javax.naming.NamingException e)
         {
        	 e.printStackTrace();
            // No reverse DNS that we could find, try with InetAddress
            System.out.print(""); // NO-OP
         }
      }

      if (null == retVal)
      {
         try
         {
            retVal = java.net.InetAddress.getByName(ip).getCanonicalHostName();
         }
         catch (final java.net.UnknownHostException e1)
         {
            retVal = ip;
         }
      }

      return retVal;
    }

	public static int[] DNSfeatures(String whoisData1, String dom){
		
		int[] dnsvector= {0,0,0,0,0,0,0,0,0,0,0,0,0};//thirteen DNS features.
		//1, whether have DNS record
		//2, whether Expiration date more than one year.
		//3, whether Creation date more than one year ago.
		//4, Number of distinct IP addresses
		//5, Number of distinct countries
		//6, Number of domains share the IP with
		//7, Whether have valid contact email
		//8, Reverse DNS query results: whether domain in top 3 results
		//9, Average TTL, TTL data cached in DNS server.
	    //10, Standard Deviation of TTL
		//11, Number of distinct TTL values
		//12, Number of TTL change
		//13, Percentage usage of specific TTL ranges 
	
		if(whoisData1.length()<50){
			return dnsvector;
		}
		if (!whoisData1.contains("Expiration Date: ")){
			return dnsvector;
		}
		dnsvector[0] = 1;
		Date today = new Date();
		Calendar cal = Calendar.getInstance();
	    cal.setTime(today);
		int year = cal.get(Calendar.YEAR);
		String expdate = whoisData1.split("Expiration Date: ")[1].split("\n")[0];
        int e = Integer.parseInt(expdate.substring(7));
        //System.out.println(whoisData1);
        //System.out.println(today);
        if(e-year>1){
        	dnsvector[1] = 1;
        }
        String credate = whoisData1.split("Creation Date: ")[1].split("\n")[0];
        int cre = Integer.parseInt(credate.substring(7));
        if(year-cre >1){
        	dnsvector[2] = 1;
        }
        Matcher matcher = pattern.matcher(whoisData1);
        int count = 0;
        String ip  = "0";
        if(matcher.find()){
        	count++;
        	ip = matcher.group(0);
        }
        
        
        while (matcher.find())
            count++;
        //System.out.println(count);
        dnsvector[3] = count;
        //this is for counting countries
        //pattern2 is to count different servers in different countries
        count = 0;
        Matcher matcher2 = pattern2.matcher(whoisData1);
        while (matcher2.find())
            count++;
        dnsvector[4] = count;
        //Ip shared by different domains
        if(count!=0){
        dnsvector[5] = (int) Math.ceil(dnsvector[3]*1.0/count);}
        Matcher matcher3 = pattern3.matcher(whoisData1);
        if(matcher3.find())
        	dnsvector[6] = 1;
        if(dnsvector[3]==0){
        	dnsvector[7] = 0;
        } else {
        	//String ip = matcher.group(0);
        	String dd = getHostName(ip); //reverse DNS query.
        	if(dd.toLowerCase().contains(dom.toLowerCase())){
        		dnsvector[7] = 1;
        	}
        }
        try{
        InetAddress inetAddress = InetAddress.getByName(dom);
        //if(Security.getProperty("networkaddress.cache.ttl").isEmpty()){
        //	dnsvector[8]=1;
        //}
        
        if(inetAddress.isReachable(500)){
        	dnsvector[9]=1;
        }
        if(inetAddress.isReachable(1000)){
        	dnsvector[10]=1;
        }
        if(inetAddress.isReachable(1500)){
        	dnsvector[11]=1;
        }
        if(inetAddress.isReachable(2000)){
        	dnsvector[12]=1;
        }
        } catch(Exception s)
    	{	
        	s.printStackTrace();
    		System.out.println(s);
    	}
        return dnsvector;
	}
    
    
    
    
    public static void testfunction(String filename){
    
    	
    	try{
    	Scanner dinput;
    	dinput = new Scanner(new File(filename));
    	PrintWriter writer = new PrintWriter("testinput5000_twomore.arff", "UTF-8");
		writer.println("@relation DGAscore");
		writer.println("@attribute meaning numeric");
		writer.println("@attribute max numeric");
		writer.println("@attribute nupor numeric");
		writer.println("@attribute pronounceability numeric");
		writer.println("@attribute dns numeric");
		writer.println("@attribute exp numeric");
		writer.println("@attribute cre numeric");
		writer.println("@attribute ip numeric");
		writer.println("@attribute con numeric");
		writer.println("@attribute ipshare numeric");
		writer.println("@attribute vemail numeric");
		writer.println("@attribute rdns numeric");
		writer.println("@attribute aTTL numeric");
		writer.println("@attribute sdTTL numeric");
		writer.println("@attribute nTTL numeric");
		writer.println("@attribute cTTL numeric");
		writer.println("@attribute pTTL numeric");
		writer.println("@attribute class {DGA, normal}");
		writer.println("@data");
		//7, Whether have valid contact email
				//8, Reverse DNS query results: whether domain in top 3 results
				//9, Average TTL, TTL data cached in DNS server.
			    //10, Standard Deviation of TTL
				//11, Number of distinct TTL values
				//12, Number of TTL change
				//13, Percentage usage of specific TTL ranges 
    	for(int i = 0; i<5000;i++){
    		String tem = dinput.nextLine();
    		//System.out.println(tem);
    		int[] dnsf = {0,0,0,0,0,0,0,0,0,0,0,0,0};
    		if(i>2500){
    			String whoisdata = whoisdata(tem);
    			if(whoisdata.length()>50){
    			dnsf = DNSfeatures(whoisdata,tem);
    			}
    		}
    		
    		
    		
    		
    		//System.out.println(dnsf.toString());
    		
    		
    		
    		double[] s = meaning_word_score(tem);
    		double pro = prouncval(tem);
    		if(i<2500){
    		writer.println(Double.toString(s[0])+","+Double.toString(s[1])+","+Double.toString(s[2])+","+Double.toString(pro)+","+Integer.toString(dnsf[0])+","+Integer.toString(dnsf[1])+","+Integer.toString(dnsf[2])+","+Integer.toString(dnsf[3])+","+Integer.toString(dnsf[4])+","+Integer.toString(dnsf[5])+","+Integer.toString(dnsf[6])+","+Integer.toString(dnsf[7])+","+Integer.toString(dnsf[8])+","+Integer.toString(dnsf[9])+","+Integer.toString(dnsf[10])+","+Integer.toString(dnsf[11])+","+Integer.toString(dnsf[12])+",DGA");
    		//System.out.println(Double.toString(s)+","+Double.toString(pro)+",DGA");
    		}
    		else{
    		
    		writer.println(Double.toString(s[0])+","+Double.toString(s[1])+","+Double.toString(s[2])+","+Double.toString(pro)+","+Integer.toString(dnsf[0])+","+Integer.toString(dnsf[1])+","+Integer.toString(dnsf[2])+","+Integer.toString(dnsf[3])+","+Integer.toString(dnsf[4])+","+Integer.toString(dnsf[5])+","+Integer.toString(dnsf[6])+","+Integer.toString(dnsf[7])+","+Integer.toString(dnsf[8])+","+Integer.toString(dnsf[9])+","+Integer.toString(dnsf[10])+","+Integer.toString(dnsf[11])+","+Integer.toString(dnsf[12])+",normal");
    		//System.out.println(Double.toString(s)+","+Double.toString(pro)+",normal");
    		}
    	}
    	writer.close();
    	dinput.close();
    	} catch(Exception e)
    	{	
    		System.out.println(e);
    		e.printStackTrace();
			System.exit(1);
    	}
    	
    	
    }
    
    public static void wekalearning(String learningfile){
    	
    	try{
    		BufferedReader reader = new BufferedReader( new FileReader(learningfile));
    		Instances data = new Instances(reader); 
    		reader.close();
    		data.setClassIndex(data.numAttributes() - 1); 
    		//String[] options = new String[2];
    		//options[0] = "-N 200";
    		//options[1] = "-L 0.1";
    		J48 ANN = new J48();
    		//MultilayerPerceptron ANN = new MultilayerPerceptron();
    		//ANN.setOptions(options);
    		//ANN.setHiddenLayers("2");
    		ANN.buildClassifier(data);
    	
    		
    		Evaluation eval = new Evaluation(data);
    		eval.crossValidateModel(ANN, data, 10, new Random(1));
    		System.out.println(eval.toSummaryString("\nResults\n======\n", false));
    		System.out.print("False positive rate is ");
    		System.out.println(eval.falsePositiveRate(0));
    		System.out.print("False negative rate is ");
    		System.out.println(eval.falseNegativeRate(0));
    		//System.out.println(eval.predictions());
    		//System.out.println(ANN.getHiddenLayers());
    		
    		
    		ThresholdCurve tc = new ThresholdCurve();
    		 int classIndex = 0;
    	     Instances result = tc.getCurve(eval.predictions(), classIndex);
    	     System.out.print("Area under ROC = ");
    	     System.out.println(ThresholdCurve.getROCArea(result));
    	     //ThresholdVisualizePanel vmc = new ThresholdVisualizePanel();
    	     //vmc.setROCString("(Area under ROC = " + Double.toString(ThresholdCurve.getROCArea(result)) + ")");
    	     /*vmc.setName(result.relationName());
    	     PlotData2D tempd = new PlotData2D(result);
    	     tempd.setPlotName(result.relationName());
    	     tempd.addInstanceNumberAttribute();
    	     boolean[] cp = new boolean[result.numInstances()];
    	     for (int n = 1; n < cp.length; n++)
    	       cp[n] = true;
    	     tempd.setConnectPoints(cp);
    	     // add plot
    	     vmc.addPlot(tempd);
    	 
    	     // display curve
    	     String plotName = vmc.getName();
    	     final javax.swing.JFrame jf =
    	       new javax.swing.JFrame("Weka Classifier Visualize: "+plotName);
    	     jf.setSize(500,400);
    	     jf.getContentPane().setLayout(new BorderLayout());
    	     jf.getContentPane().add(vmc, BorderLayout.CENTER);
    	     jf.addWindowListener(new java.awt.event.WindowAdapter() {
    	       public void windowClosing(java.awt.event.WindowEvent e) {
    	       jf.dispose();
    	       }
    	     });
    	     jf.setVisible(true);*/
    		Debug.saveToFile("ANNmodel.mdl", ANN);

    		
    		
    	} catch(Exception e)
    	{	
    		e.printStackTrace();
    		System.out.println(e);
    		//System.exit(1);
    	}
    	
    }
    
    public static void wekapredict(String domainname){
    	SerializedClassifier ANN = new SerializedClassifier();
    	ANN.setModelFile(new File("ANNmodel.mdl"));
    	
    	
    	try{
    		BufferedReader reader = new BufferedReader( new FileReader("testinput5000_all.arff"));
    		Instances data = new Instances(reader); 
    		reader.close();
    		data.setClassIndex(data.numAttributes() - 1); 
    		Instance inst = new DenseInstance(17);
    		double[] s = meaning_word_score(domainname);
    		inst.setDataset(data);
    		String whoisdata = whoisdata(domainname);
    		int[] dnsf = DNSfeatures(whoisdata,domainname);
        	inst.setValue(0, s[0]);
        	inst.setValue(1, s[1]);
        	inst.setValue(2, s[2]);
        	inst.setValue(3, prouncval(domainname));
        	for(int i=0; i<13;i++){
        		inst.setValue(4+i, dnsf[i]);
        	}
        	//inst.setValue(2, "normal");
        	
    		
    		
    		
    		double result = ANN.classifyInstance(inst);
    		System.out.print("predict:");
    		System.out.println(result);
    		
    		//System.out.println(data);
    	}	catch(Exception e)
    	{	
    		e.printStackTrace();
    		System.out.println(e);
    		//System.exit(1);
    	}
    }

    public static void clusting (){
    	
    }
    
    
	private static void printAddressInfo(String name, InetAddress... hosts) throws Exception {
		System.out.println("===== Printing Info for: '" + name + "' =====");
		for(InetAddress host : hosts) {			
			System.out.println("Host Name: " + host.getHostName());
			System.out.println("Canonical Host Name: " + host.getCanonicalHostName());
			System.out.println("Host Address: " + host.getHostAddress());
			System.out.println("Calculated Host Address: " + getIpAsString(host));
			System.out.print("Is Any Local: " + host.isAnyLocalAddress());
			System.out.print(" - Is Link Local: " + host.isLinkLocalAddress());
			System.out.print(" - Is Loopback: " + host.isLoopbackAddress());
			System.out.print(" - Is Multicast: " + host.isMulticastAddress());
			System.out.println(" - Is Site Local: " + host.isSiteLocalAddress());
			System.out.println("Is Reachable in 2 seconds: " + host.isReachable(2000));
		}
	}
    
	private static String getIpAsString(InetAddress address) {
		byte[] ipAddress = address.getAddress();
		StringBuffer str = new StringBuffer();
		for(int i=0; i<ipAddress.length; i++) {
			if(i > 0) str.append('.');
			str.append(ipAddress[i] & 0xFF);				
		}
		return str.toString();
	}
	
	private static Pattern pDomainNameOnly;
	private static final String DOMAIN_NAME_PATTERN = "^((?!-)[A-Za-z0-9-]{1,63}(?<!-)\\.)+[A-Za-z]{2,6}$";

	static {
		pDomainNameOnly = Pattern.compile(DOMAIN_NAME_PATTERN);
	}
    
	public static void main(String[] args)throws Exception
	{
	
		
		/*String test = "facebook.com";
		double s = meaning_word_score(test);
		double pro=prouncval(test);
		System.out.println("Meaning score:"+Double.toString(s)+" Pro score:"+Double.toString(pro));*/
		//mixinput();
		//testfunction("testinputNorandom.txt");
		
		
		//wekalearning("testinput5000_all.arff");
		//double s[] = meaning_word_score(test);
		//System.out.println("Meaning score:"+Double.toString(s[0])+" max:"+ Double.toString(s[1]));
		//testfunction("2500do");
		
		
		//wekapredict("aabbecss.com");
		
		/*
		String scan;
		Scanner r = new Scanner(System.in);
		while(true){	
			while(r.hasNextLine()) {
	            scan = r.nextLine();
	            if(scan.length()==0) {continue;}
	            Matcher domainame = pDomainNameOnly.matcher(scan);
	            while(domainame.find()){
	            	final long startTime = System.currentTimeMillis();
	            	String domm = domainame.group(0);
	            	//String domm1 = domainame.group(1);
	            	wekapredict(domm);
	            	final long endTime = System.currentTimeMillis();
	            	System.out.println("Total execution time: " + (endTime - startTime)*1.0/1000 + "s" );
	            }
	            //treatment
	        }
		}*/
		Vector<Point> D = Dbscanfunction.getList("DGA_test");
		Vector<List> resultls = Dbscanfunction.DBSCAN(D);
		
		
		
		
		//r.close();
		//wekapredict("facebook.com");
		//String whoisData1 = whoisdata("fvbtrh");
		//System.out.println(whoisData1);
		//int[] ds = DNSfeatures(whoisData1);
		//for(int i=0;i<ds.length;i++)System.out.println(ds[i]);
	}
	
}
